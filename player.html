<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MemoryRoom ‚Äì Player</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
  <style>
    :root { --bg:#0b1020; --muted:#98a7ff99; --accent:#7aa2ff; }
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;background:radial-gradient(900px 600px at 10% 10%, #18214d 0%, #0b1020 60%);color:#fff}
    .wrap{max-width:900px;margin:0 auto;padding:28px}
    h1{font-size:28px;margin:0 0 8px;display:flex;align-items:center;gap:10px}
    .logo{width:36px;height:36px;border-radius:8px;object-fit:cover;border:1px solid rgba(255,255,255,.25)}
    .sub{color:var(--muted);margin:0 0 24px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));border:1px solid rgba(255,255,255,.08);border-radius:18px;padding:18px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    input{width:100%;padding:12px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.15);background:#0f1530;color:#fff}
    button{cursor:pointer;border:0;background:var(--accent);color:#081126;padding:12px 16px;border-radius:12px;font-weight:700}
    button.ghost{background:transparent;color:#cfe0ff;border:1px solid rgba(255,255,255,.18)}
    .muted{color:var(--muted)}
    .pill{background:#0e1533;border:1px solid rgba(255,255,255,.14);padding:6px 10px;border-radius:999px;color:#cfe0ff;font-weight:600;display:inline-flex;gap:8px;align-items:center}
    .hr{height:1px;background:rgba(255,255,255,.08);margin:14px 0}
    .ans{background:#0c1330;border:1px solid rgba(255,255,255,.12);padding:14px;border-radius:14px;min-height:120px;font-size:18px;line-height:1.3;color:#eaf0ff;white-space:normal;word-break:break-word;display:flex;align-items:center;justify-content:center}
    .ans:disabled{color:#eaf0ff;opacity:.95}
    .ans.hidden:disabled{color:#ffb3b3}
    @media (max-width:640px){.ans{min-height:90px;font-size:16px}}
    .ans.hidden{color:#ff7a7a;font-weight:800}
    .ans.revealed{background:#0f1a44;border-color:#6ea8ff;box-shadow:0 0 0 2px rgba(110,168,255,.18) inset}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>
      <img class="logo" id="logo"
           src="https://images.prismic.io/quizlet-web/ZuOC_7VsGrYSvUXJ_VI-VN7Match.png?auto=format,compress"
           alt="logo"/>
      MemoryRoom üé¥ ‚Äì Player
    </h1>
    <p class="sub">M·ªói ng∆∞·ªùi ch∆°i c√≥ <b>b√†n ri√™ng</b> trong c√πng m·ªôt ph√≤ng. Ho√†n th√†nh s·ªõm s·∫Ω t·ª± chuy·ªÉn v√≤ng ti·∫øp theo cho t·ªõi khi h·∫øt th·ªùi gian phi√™n.</p>

    <div class="card">
      <div class="row">
        <input id="joinRoom" placeholder="M√£ ph√≤ng"/>
        <input id="nickname" placeholder="T√™n c·ªßa b·∫°n"/>
        <button id="joinBtn">Tham gia</button>
      </div>
      <div class="hr"></div>

      <div id="playerArea" style="display:none">
        <div class="row" style="justify-content:space-between;gap:8px">
          <span class="pill">Ph√≤ng: <span id="roomBadge">-</span></span>
          <span class="pill">B·∫°n: <span id="me">-</span></span>
          <span class="pill">C√≤n c·∫∑p: <span id="memLeft">--</span></span>
          <span class="pill">V√°n: <span id="roundPlayer">-</span>/<span id="roundMax">-</span></span>
          <span class="pill">‚è± C√≤n: <span id="timeRemain">--:--</span></span>
        </div>
        <div class="hr"></div>
        <div id="board" style="display:grid;gap:12px"></div>
        <div class="muted" id="hint">Ch·ªçn 2 th·∫ª ƒë·ªÉ l·∫≠t</div>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getDatabase, ref, onValue, update, set, get } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

    // Firebase config (gi·ªëng host)
    const firebaseConfig = {
      apiKey: "AIzaSyDA3fp5A2cGB63kMA8TlEJ2x49rr4DiYbA",
      authDomain: "game-75e2a.firebaseapp.com",
      databaseURL: "https://game-75e2a-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "game-75e2a",
      storageBucket: "game-75e2a.firebasestorage.app",
      messagingSenderId: "763894782961",
      appId: "1:763894782961:web:84465068beb77de8024250",
      measurementId: "G-E10MQ37X5Y",
    };
    const app = initializeApp(firebaseConfig);
    const db  = getDatabase(app);

    const $ = (id) => document.getElementById(id);
    const qp = (name)=> new URL(location.href).searchParams.get(name);
    const roomFromUrl = qp("room"); if(roomFromUrl) $("joinRoom").value = roomFromUrl;

    let joinedRoomId=null, myId=null, sessionTimer=null;
    let cachedPairs=null, cachedOrder=null, cachedSessMeta=null; // room-level metadata
    const DEFAULT_COLS = 4;

    // ---- JOIN ----
    $("joinBtn").onclick = async ()=>{
      const room=$("joinRoom").value.trim().toUpperCase();
      const name=$("nickname").value.trim();
      if(!room || !name) return alert("Nh·∫≠p m√£ ph√≤ng & t√™n");

      joinedRoomId=room;
      myId = "p_" + Math.random().toString(36).slice(2,8);

      await update(ref(db,`rooms/${room}/players/${myId}`), {name, score:0, joinedAt:Date.now()});
      await update(ref(db,`rooms/${room}/scores/${myId}`),  {name, score:0});

      $("playerArea").style.display='block';
      $("roomBadge").textContent=room; $("me").textContent=name;

      await bindRoomSession();   // timer + roundsMax + load pairs/order
      await bindMySession();     // round + state render
    };

    // ---- ROOM-LEVEL: timer & roundsMax & pairs/order ----
    async function bindRoomSession(){
      onValue(ref(db, `rooms/${joinedRoomId}/memory/meta/session`), (snap)=>{
        cachedSessMeta = snap.val() || null;
        $("roundMax").textContent = cachedSessMeta?.roundsMax ?? "-";
        // timer
        if(sessionTimer) clearInterval(sessionTimer);
        if(!cachedSessMeta?.endAt){ $("timeRemain").textContent="--:--"; return; }
        sessionTimer = setInterval(()=>{
          const remain = Math.max(0, cachedSessMeta.endAt - Date.now());
          const m = Math.floor(remain/60000), s = Math.floor((remain%60000)/1000);
          $("timeRemain").textContent = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
        }, 500);
      });

      // Pairs & order (d√πng chung cho c·∫£ room)
      const pairsSnap = await get(ref(db, `rooms/${joinedRoomId}/memory/pairs`));
      const orderSnap = await get(ref(db, `rooms/${joinedRoomId}/memory/order`));
      cachedPairs = pairsSnap.val() || [];
      cachedOrder = orderSnap.val() || [];
    }

    // ---- PLAYER SESSION: meta + state (deck ri√™ng) ----
    async function bindMySession(){
      const myMetaRef  = ref(db, `rooms/${joinedRoomId}/sessions/${myId}/meta`);
      const myStateRef = ref(db, `rooms/${joinedRoomId}/sessions/${myId}/state`);

      // n·∫øu ch∆∞a c√≥ round -> set 1 v√† t·∫°o b√†n ƒë·∫ßu
      const m = (await get(myMetaRef)).val();
      if(!m || !m.round){
        await set(myMetaRef, { round: 1, left: 0 });
        await ensureRoundState(1);
      }

      // theo d√µi meta c·ªßa t√¥i (round/left)
      onValue(myMetaRef, (snap)=>{
        const meta = snap.val() || {};
        $("roundPlayer").textContent = meta.round ?? "-";
        $("memLeft").textContent = (Number.isFinite(meta.left) ? meta.left : "--");
      });

      // theo d√µi state c·ªßa t√¥i ƒë·ªÉ render board
      onValue(myStateRef, async (snap)=>{
        const st = snap.val();
        const board = $("board");
        if(!st){
          board.innerHTML = '<div class="muted">Ch·ªù kh·ªüi t·∫°o b√†n‚Ä¶</div>';
          return;
        }
        const ended = !!(cachedSessMeta && (cachedSessMeta.endAt || 0) <= Date.now());
        board.style.gridTemplateColumns = `repeat(${st.cols||DEFAULT_COLS}, minmax(0,1fr))`;
        board.innerHTML = "";
        (st.deck||[]).forEach(card=>{
          const btn = document.createElement("button");
          const flipped = (st.flipped||[]).includes(card.id);
          btn.className = "ans " + ((flipped||card.removed)? "revealed":"hidden");
          btn.style.height="120px";
          btn.disabled = card.removed || st.lock || ended;
          btn.textContent = (flipped||card.removed) ? card.text : "?";
          if(card.removed) btn.style.visibility="hidden";
          btn.onclick = ()=> flipMyCard(card.id);
          board.appendChild(btn);
        });
        $("hint").textContent = ended ? "H·∫øt th·ªùi gian phi√™n." : (st.lock? "ƒêang ki·ªÉm tra c·∫∑p‚Ä¶":"Ch·ªçn 2 th·∫ª ƒë·ªÉ l·∫≠t");
      });
    }

    // ---- Utility: chia ch·ªâ s·ªë c√¢u theo round 6‚Äì7 ----
    function sliceIndicesForRound(sessionMeta, roundIndex, orderLen){
      const base  = sessionMeta?.baseSize || 6;
      const extra = sessionMeta?.extra    || 0;
      const prior7 = Math.min(roundIndex-1, extra);
      const prior6 = Math.max(0, (roundIndex-1)-extra);
      const start  = prior7*(base+1) + prior6*base;
      const len    = (roundIndex-1) < extra ? (base+1) : base;
      const end    = Math.min(start + len, orderLen);
      return { start, end, len };
    }

    // ---- T·∫°o b√†n cho v√≤ng (ri√™ng ng∆∞·ªùi ch∆°i) ----
    async function ensureRoundState(round){
      if(!cachedPairs || !cachedOrder || !cachedSessMeta){
        // ƒë·ª£i host b·∫Øt ƒë·∫ßu phi√™n
        return;
      }
      const { start, end, len } = sliceIndicesForRound(cachedSessMeta, round, cachedOrder.length);
      const indices = cachedOrder.slice(start, end);
      const subset  = indices.map(i => cachedPairs[i]); // [{q,a}...]

      // d·ª±ng deck ri√™ng
      let cid=0, deck=[];
      subset.forEach((p, idx)=>{
        deck.push({ id: cid++, pair: idx, text: p.q, removed:false });
        deck.push({ id: cid++, pair: idx, text: p.a, removed:false });
      });
      // x√°o tr·ªôn deck (per-player)
      for(let i=deck.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [deck[i],deck[j]]=[deck[j],deck[i]]; }

      // ghi state & meta ri√™ng
      await set(ref(db, `rooms/${joinedRoomId}/sessions/${myId}/state`), {
        cols: DEFAULT_COLS,
        pts: 5,
        deck, flipped: [], lock:false
      });
      await update(ref(db, `rooms/${joinedRoomId}/sessions/${myId}/meta`), {
        round, left: subset.length
      });
    }

    // ---- L·∫≠t th·∫ª (ri√™ng b√†n c·ªßa t√¥i) ----
    async function flipMyCard(cardId){
      // kh√≥a theo room timer
      if(cachedSessMeta && (cachedSessMeta.endAt||0) <= Date.now()) return;

      const baseRef = ref(db, `rooms/${joinedRoomId}/sessions/${myId}/state`);
      const st = (await get(baseRef)).val(); if(!st || st.lock) return;

      const card = st.deck.find(c=>c.id===cardId); if(!card || card.removed) return;
      if((st.flipped||[]).includes(cardId)) return;

      const flipped = [...(st.flipped||[]), cardId];
      await update(baseRef, { flipped });

      if(flipped.length===2){
        await update(baseRef, { lock:true });
        const [c1,c2] = flipped.map(id=> st.deck.find(c=>c.id===id));
        const match = c1.pair===c2.pair && c1.id!==c2.id;

        if(match){
          st.deck = st.deck.map(c=> (c.id===c1.id||c.id===c2.id) ? {...c, removed:true} : c);
          await update(baseRef, { deck:st.deck, flipped:[], lock:false });

          // c·∫≠p nh·∫≠t meta.left c·ªßa ri√™ng t√¥i
          const myMetaRef = ref(db, `rooms/${joinedRoomId}/sessions/${myId}/meta`);
          const m = (await get(myMetaRef)).val() || {round:1,left:0};
          const newLeft = Math.max(0, (m.left||0)-1);
          await update(myMetaRef, { left:newLeft });

          // c·ªông ƒëi·ªÉm c√° nh√¢n (gi·ªØ nh∆∞ c≈©)
          const sRef = ref(db, `rooms/${joinedRoomId}/scores/${myId}`);
          const p = (await get(sRef)).val() || {name:$("me").textContent, score:0};
          await update(sRef, { name:p.name||$("me").textContent, score:(p.score||0)+ (st.pts||5) });

          // auto next v√≤ng n·∫øu c√≤n th·ªùi gian & ch∆∞a ƒë·∫°t roundsMax
          if(newLeft===0 && cachedSessMeta){
            const remain = Math.max(0, cachedSessMeta.endAt - Date.now());
            const maxR = cachedSessMeta.roundsMax || 1;
            if(remain>0 && m.round < maxR){
              const next = m.round + 1;
              await update(myMetaRef, { round: next });
              await ensureRoundState(next);
            }
          }
        } else {
          setTimeout(async ()=>{ await update(baseRef, { flipped:[], lock:false }); }, 900);
        }
      }
    }
  </script>
</body>
</html>
